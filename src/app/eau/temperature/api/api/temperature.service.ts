/**
 * API Hub\'Eau - Température des cours d\'eau en continu
 * Adresse de la documentation http://hubeau.eaufrance.fr/page/api-temperature-en-continu-cours-deau
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { ChroniqueBE } from '../model/chronique';
// @ts-ignore
import { MessagederreurBE } from '../model/messagederreur';
// @ts-ignore
import { RsultatdunerquetesurleschroniquesBE } from '../model/rsultatdunerquetesurleschroniques';
// @ts-ignore
import { RsultatdunerquetesurlesstationsBE } from '../model/rsultatdunerquetesurlesstations';
// @ts-ignore
import { StationBE } from '../model/station';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


export interface ChroniquesRequestParams {
    /** Code de la station de mesure: Identifiant de la station de mesure dans le référentiel national Sandre, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeStation?: Array<string>;
    /** Libellé national de la station de mesure, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleStation?: Array<string>;
    /** Code INSEE de la commune où est implantée la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  50 */
    codeCommune?: Array<string>;
    /** Libellé long de la commune, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  50 */
    libelleCommune?: Array<string>;
    /** Code du département, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  20 */
    codeDepartement?: Array<string>;
    /** Libellé long du département, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  20 */
    libelleDepartement?: Array<string>;
    /** Code de la région (INSEE), si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeRegion?: Array<string>;
    /** Libellé long de la région, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleRegion?: Array<string>;
    /** Code du tronçon hydrographique associé à la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeTronconHydro?: Array<string>;
    /** Code du du cours d\&#39;eau, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeCoursEau?: Array<string>;
    /** Libellé long du cours d\&#39;eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleCoursEau?: Array<string>;
    /** Code national de la masse d’eau de la station de mesure, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeMasseEau?: Array<string>;
    /** Nom de la masse d’eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleMasseEau?: Array<string>;
    /** Code européen du sous-bassin DCE administratif, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeSousBassin?: Array<string>;
    /** Nom du sous bassin DCE administratif, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleSousBassin?: Array<string>;
    /** Code national du bassin DCE, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeBassin?: Array<string>;
    /** Nom du bassin DCE, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleBassin?: Array<string>;
    /** Rectangle d\&#39;emprise de l\&#39;objet demandé, emprise au format : min longitude, min latitude, max longitude, max latitude avec les coordonnées en WGS84 (EPSG:4326), le point doit être utilisé comme séparateur décimal, exemple : 1.6194,47.7965,2.1910,47.9988 */
    bbox?: Array<number>;
    /** Nombre maximum de résultats dans une page */
    size?: number;
    /** Liste des champs souhaités dans la réponse (fonctionnalité expérimentale), par exemple fields&#x3D;code_station,localisation */
    fields?: string;
    /** Numéro de la page */
    page?: number;
    /** Date de début des mesures de températures : renvoie toutes les mesures à partir de cette date */
    dateDebutMesure?: string;
    /** Date de fin des mesures de températures : renvoie toutes les mesures antérieures à cette date */
    dateFinMesure?: string;
    /** Valeur minimale (inclue) du résultat de l\&#39;analyse : renvoie toutes les mesures supérieures ou égales à cette valeur */
    resultatMin?: number;
    /** Valeur maximale (inclue) du résultat de l\&#39;analyse : renvoie toutes les mesures inférieures ou égales à cette valeur */
    resultatMax?: number;
    /** Longitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 1.937 */
    longitude?: number;
    /** Latitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 47.829 */
    latitude?: number;
    /** Rayon de recherche en kilomètre, le point doit être utilisé comme séparateur décimal, exemple : 30 */
    distance?: number;
    /** Ordre de tri (asc ou desc) sur la date de la mesure (si la valeur n\&#39;est pas renseignée, la valeur par défaut est asc) */
    sort?: 'asc' | 'desc';
}

export interface ChroniquesCsvRequestParams {
    /** Code de la station de mesure: Identifiant de la station de mesure dans le référentiel national Sandre, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeStation?: Array<string>;
    /** Libellé national de la station de mesure, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleStation?: Array<string>;
    /** Code INSEE de la commune où est implantée la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  50 */
    codeCommune?: Array<string>;
    /** Libellé long de la commune, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  50 */
    libelleCommune?: Array<string>;
    /** Code du département, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  20 */
    codeDepartement?: Array<string>;
    /** Libellé long du département, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  20 */
    libelleDepartement?: Array<string>;
    /** Code de la région (INSEE), si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeRegion?: Array<string>;
    /** Libellé long de la région, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleRegion?: Array<string>;
    /** Code du tronçon hydrographique associé à la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeTronconHydro?: Array<string>;
    /** Code du du cours d\&#39;eau, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeCoursEau?: Array<string>;
    /** Libellé long du cours d\&#39;eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleCoursEau?: Array<string>;
    /** Code national de la masse d’eau de la station de mesure, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeMasseEau?: Array<string>;
    /** Nom de la masse d’eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleMasseEau?: Array<string>;
    /** Code européen du sous-bassin DCE administratif, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeSousBassin?: Array<string>;
    /** Nom du sous bassin DCE administratif, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleSousBassin?: Array<string>;
    /** Code national du bassin DCE, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeBassin?: Array<string>;
    /** Nom du bassin DCE, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleBassin?: Array<string>;
    /** Rectangle d\&#39;emprise de l\&#39;objet demandé, emprise au format : min longitude, min latitude, max longitude, max latitude avec les coordonnées en WGS84 (EPSG:4326), le point doit être utilisé comme séparateur décimal, exemple : 1.6194,47.7965,2.1910,47.9988 */
    bbox?: Array<number>;
    /** Nombre maximum de résultats dans une page */
    size?: number;
    /** Liste des champs souhaités dans la réponse (fonctionnalité expérimentale), par exemple fields&#x3D;code_station,localisation */
    fields?: string;
    /** Numéro de la page */
    page?: number;
    /** Date de début des mesures de températures : renvoie toutes les mesures à partir de cette date */
    dateDebutMesure?: string;
    /** Date de fin des mesures de températures : renvoie toutes les mesures antérieures à cette date */
    dateFinMesure?: string;
    /** Valeur minimale (inclue) du résultat de l\&#39;analyse : renvoie toutes les mesures supérieures ou égales à cette valeur */
    resultatMin?: number;
    /** Valeur maximale (inclue) du résultat de l\&#39;analyse : renvoie toutes les mesures inférieures ou égales à cette valeur */
    resultatMax?: number;
    /** Longitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 1.937 */
    longitude?: number;
    /** Latitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 47.829 */
    latitude?: number;
    /** Rayon de recherche en kilomètre, le point doit être utilisé comme séparateur décimal, exemple : 30 */
    distance?: number;
    /** Ordre de tri (asc ou desc) sur la date de la mesure (si la valeur n\&#39;est pas renseignée, la valeur par défaut est asc) */
    sort?: 'asc' | 'desc';
}

export interface StationCsvRequestParams {
    /** Code de la station de mesure: Identifiant de la station de mesure dans le référentiel national Sandre, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeStation?: Array<string>;
    /** Libellé national de la station de mesure, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleStation?: Array<string>;
    /** Code INSEE de la commune où est implantée la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  50 */
    codeCommune?: Array<string>;
    /** Libellé long de la commune, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  50 */
    libelleCommune?: Array<string>;
    /** Code du département, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  20 */
    codeDepartement?: Array<string>;
    /** Libellé long du département, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  20 */
    libelleDepartement?: Array<string>;
    /** Code de la région (INSEE), si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeRegion?: Array<string>;
    /** Libellé long de la région, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleRegion?: Array<string>;
    /** Code du tronçon hydrographique associé à la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeTronconHydro?: Array<string>;
    /** Code du du cours d\&#39;eau, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeCoursEau?: Array<string>;
    /** Libellé long du cours d\&#39;eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleCoursEau?: Array<string>;
    /** Code national de la masse d’eau de la station de mesure, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeMasseEau?: Array<string>;
    /** Nom de la masse d’eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleMasseEau?: Array<string>;
    /** Code européen du sous-bassin DCE administratif, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeSousBassin?: Array<string>;
    /** Nom du sous bassin DCE administratif, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleSousBassin?: Array<string>;
    /** Code national du bassin DCE, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeBassin?: Array<string>;
    /** Nom du bassin DCE, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleBassin?: Array<string>;
    /** Rectangle d\&#39;emprise de l\&#39;objet demandé, emprise au format : min longitude, min latitude, max longitude, max latitude avec les coordonnées en WGS84 (EPSG:4326), le point doit être utilisé comme séparateur décimal, exemple : 1.6194,47.7965,2.1910,47.9988 */
    bbox?: Array<number>;
    /** Nombre maximum de résultats dans une page */
    size?: number;
    /** Liste des champs souhaités dans la réponse (fonctionnalité expérimentale), par exemple fields&#x3D;code_station,localisation */
    fields?: string;
    /** Numéro de la page */
    page?: number;
    /** Date de début des mesures de températures : renvoie toutes les stations ayant des mesures à partir de cette date */
    dateDebutMesure?: string;
    /** Date de fin des mesures de températures : renvoie toutes les stations ayant des mesures antérieures à cette date */
    dateFinMesure?: string;
    /** Longitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 1.937 */
    longitude?: number;
    /** Latitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 47.829 */
    latitude?: number;
    /** Rayon de recherche en kilomètre, le point doit être utilisé comme séparateur décimal, exemple : 30 */
    distance?: number;
    /** Si égal true permet d\&#39;avoir une pagination (count, last) exacte mais la réponse est moins rapide, sinon (false) c\&#39;est une approximation mais la réponse est plus rapide (défaut : true) */
    exactCount?: boolean;
}

export interface StationsRequestParams {
    /** Code de la station de mesure: Identifiant de la station de mesure dans le référentiel national Sandre, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeStation?: Array<string>;
    /** Libellé national de la station de mesure, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleStation?: Array<string>;
    /** Code INSEE de la commune où est implantée la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  50 */
    codeCommune?: Array<string>;
    /** Libellé long de la commune, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  50 */
    libelleCommune?: Array<string>;
    /** Code du département, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  20 */
    codeDepartement?: Array<string>;
    /** Libellé long du département, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  20 */
    libelleDepartement?: Array<string>;
    /** Code de la région (INSEE), si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeRegion?: Array<string>;
    /** Libellé long de la région, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleRegion?: Array<string>;
    /** Code du tronçon hydrographique associé à la station, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeTronconHydro?: Array<string>;
    /** Code du du cours d\&#39;eau, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeCoursEau?: Array<string>;
    /** Libellé long du cours d\&#39;eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleCoursEau?: Array<string>;
    /** Code national de la masse d’eau de la station de mesure, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeMasseEau?: Array<string>;
    /** Nom de la masse d’eau, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleMasseEau?: Array<string>;
    /** Code européen du sous-bassin DCE administratif, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  200 */
    codeSousBassin?: Array<string>;
    /** Nom du sous bassin DCE administratif, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  200 */
    libelleSousBassin?: Array<string>;
    /** Code national du bassin DCE, si plusieurs codes, séparer les codes par une virgule, le nombre maximum de code est  10 */
    codeBassin?: Array<string>;
    /** Nom du bassin DCE, si plusieurs libellés, séparer les libellés par une virgule, le nombre maximum de libellé est  10 */
    libelleBassin?: Array<string>;
    /** Rectangle d\&#39;emprise de l\&#39;objet demandé, emprise au format : min longitude, min latitude, max longitude, max latitude avec les coordonnées en WGS84 (EPSG:4326), le point doit être utilisé comme séparateur décimal, exemple : 1.6194,47.7965,2.1910,47.9988 */
    bbox?: Array<number>;
    /** Nombre maximum de résultats dans une page */
    size?: number;
    /** Liste des champs souhaités dans la réponse (fonctionnalité expérimentale), par exemple fields&#x3D;code_station,localisation */
    fields?: string;
    /** Numéro de la page */
    page?: number;
    /** Date de début des mesures de températures : renvoie toutes les stations ayant des mesures à partir de cette date */
    dateDebutMesure?: string;
    /** Date de fin des mesures de températures : renvoie toutes les stations ayant des mesures antérieures à cette date */
    dateFinMesure?: string;
    /** Longitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 1.937 */
    longitude?: number;
    /** Latitude du point en WGS84 pour la recherche par rayon, le point doit être utilisé comme séparateur décimal, exemple : 47.829 */
    latitude?: number;
    /** Rayon de recherche en kilomètre, le point doit être utilisé comme séparateur décimal, exemple : 30 */
    distance?: number;
    /** Si égal true permet d\&#39;avoir une pagination (count, last) exacte mais la réponse est moins rapide, sinon (false) c\&#39;est une approximation mais la réponse est plus rapide (défaut : true) */
    exactCount?: boolean;
    /** Format de réponse attendu. Supportés : json, geojson (défaut : json) */
    format?: 'json' | 'geojson';
}


@Injectable({
  providedIn: 'root'
})
export class TemperatureService {

    protected basePath = 'http://hubeau.eaufrance.fr/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Lister les chroniques de température
     * Ce service permet de rechercher des chroniques de température sur des cours d\&#39;eau et plan d\&#39;eau en France et les DROM.&lt;br/&gt;Source de données : Naïades est l\&#39;interface nationale pour l\&#39;accès aux données des rivières et des lacs. &lt;a href&#x3D;\&#39;http://naiades.eaufrance.fr/acces-donnees#/temperature\&#39; target&#x3D;\&#39;_blank\&#39;&gt;http://naiades.eaufrance.fr/acces-donnees#/temperature&lt;/a&gt;&lt;br/&gt;Si la valeur du paramètre size n\&#39;est pas renseignée, la taille de page par défaut : 1000, taille max de la page : 5000.&lt;br/&gt;La profondeur d\&#39;accès aux résultats est : 20000, calcul de la profondeur &#x3D; numéro de la page * nombre maximum de résultats dans une page.&lt;br/&gt;Trie par défaut : code_station asc, date_mesure_temp asc, heure_mesure_temp asc
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chroniques(requestParameters: ChroniquesRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<Rsultat dune rquete sur les chroniquesBE>;
    public chroniques(requestParameters: ChroniquesRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<HttpResponse<Rsultat dune rquete sur les chroniquesBE>>;
    public chroniques(requestParameters: ChroniquesRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<HttpEvent<Rsultat dune rquete sur les chroniquesBE>>;
    public chroniques(requestParameters: ChroniquesRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<any> {
        const codeStation = requestParameters.codeStation;
        const libelleStation = requestParameters.libelleStation;
        const codeCommune = requestParameters.codeCommune;
        const libelleCommune = requestParameters.libelleCommune;
        const codeDepartement = requestParameters.codeDepartement;
        const libelleDepartement = requestParameters.libelleDepartement;
        const codeRegion = requestParameters.codeRegion;
        const libelleRegion = requestParameters.libelleRegion;
        const codeTronconHydro = requestParameters.codeTronconHydro;
        const codeCoursEau = requestParameters.codeCoursEau;
        const libelleCoursEau = requestParameters.libelleCoursEau;
        const codeMasseEau = requestParameters.codeMasseEau;
        const libelleMasseEau = requestParameters.libelleMasseEau;
        const codeSousBassin = requestParameters.codeSousBassin;
        const libelleSousBassin = requestParameters.libelleSousBassin;
        const codeBassin = requestParameters.codeBassin;
        const libelleBassin = requestParameters.libelleBassin;
        const bbox = requestParameters.bbox;
        const size = requestParameters.size;
        const fields = requestParameters.fields;
        const page = requestParameters.page;
        const dateDebutMesure = requestParameters.dateDebutMesure;
        const dateFinMesure = requestParameters.dateFinMesure;
        const resultatMin = requestParameters.resultatMin;
        const resultatMax = requestParameters.resultatMax;
        const longitude = requestParameters.longitude;
        const latitude = requestParameters.latitude;
        const distance = requestParameters.distance;
        const sort = requestParameters.sort;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (codeStation) {
            codeStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_station');
            })
        }
        if (libelleStation) {
            libelleStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_station');
            })
        }
        if (codeCommune) {
            codeCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_commune');
            })
        }
        if (libelleCommune) {
            libelleCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_commune');
            })
        }
        if (codeDepartement) {
            codeDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_departement');
            })
        }
        if (libelleDepartement) {
            libelleDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_departement');
            })
        }
        if (codeRegion) {
            codeRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_region');
            })
        }
        if (libelleRegion) {
            libelleRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_region');
            })
        }
        if (codeTronconHydro) {
            codeTronconHydro.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_troncon_hydro');
            })
        }
        if (codeCoursEau) {
            codeCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_cours_eau');
            })
        }
        if (libelleCoursEau) {
            libelleCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_cours_eau');
            })
        }
        if (codeMasseEau) {
            codeMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_masse_eau');
            })
        }
        if (libelleMasseEau) {
            libelleMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_masse_eau');
            })
        }
        if (codeSousBassin) {
            codeSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_sous_bassin');
            })
        }
        if (libelleSousBassin) {
            libelleSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_sous_bassin');
            })
        }
        if (codeBassin) {
            codeBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_bassin');
            })
        }
        if (libelleBassin) {
            libelleBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_bassin');
            })
        }
        if (bbox) {
            bbox.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'bbox');
            })
        }
        if (size !== undefined && size !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>size, 'size');
        }
        if (fields !== undefined && fields !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>fields, 'fields');
        }
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (dateDebutMesure !== undefined && dateDebutMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateDebutMesure, 'date_debut_mesure');
        }
        if (dateFinMesure !== undefined && dateFinMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateFinMesure, 'date_fin_mesure');
        }
        if (resultatMin !== undefined && resultatMin !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resultatMin, 'resultat_min');
        }
        if (resultatMax !== undefined && resultatMax !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resultatMax, 'resultat_max');
        }
        if (longitude !== undefined && longitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>longitude, 'longitude');
        }
        if (latitude !== undefined && latitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>latitude, 'latitude');
        }
        if (distance !== undefined && distance !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>distance, 'distance');
        }
        if (sort !== undefined && sort !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sort, 'sort');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/javascript;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<Rsultat dune rquete sur les chroniquesBE>(`${this.configuration.basePath}/v1/temperature/chronique`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lister les chroniques de température au format CSV
     * Ce service permet de rechercher des chroniques de température sur des cours d\&#39;eau et plan d\&#39;eau en France et les DROM.&lt;br/&gt;Source de données : Naïades est l\&#39;interface nationale pour l\&#39;accès aux données des rivières et des lacs. &lt;a href&#x3D;\&#39;http://naiades.eaufrance.fr/acces-donnees#/temperature\&#39; target&#x3D;\&#39;_blank\&#39;&gt;http://naiades.eaufrance.fr/acces-donnees#/temperature&lt;/a&gt;&lt;br/&gt;Si la valeur du paramètre size n\&#39;est pas renseignée, la taille de page par défaut : 1000, taille max de la page : 5000.&lt;br/&gt;La profondeur d\&#39;accès aux résultats est : 20000, calcul de la profondeur &#x3D; numéro de la page * nombre maximum de résultats dans une page.&lt;br/&gt;Trie par défaut : code_station asc, date_mesure_temp asc, heure_mesure_temp asc
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public chroniquesCsv(requestParameters: ChroniquesCsvRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<ChroniqueBE>;
    public chroniquesCsv(requestParameters: ChroniquesCsvRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<HttpResponse<ChroniqueBE>>;
    public chroniquesCsv(requestParameters: ChroniquesCsvRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<HttpEvent<ChroniqueBE>>;
    public chroniquesCsv(requestParameters: ChroniquesCsvRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<any> {
        const codeStation = requestParameters.codeStation;
        const libelleStation = requestParameters.libelleStation;
        const codeCommune = requestParameters.codeCommune;
        const libelleCommune = requestParameters.libelleCommune;
        const codeDepartement = requestParameters.codeDepartement;
        const libelleDepartement = requestParameters.libelleDepartement;
        const codeRegion = requestParameters.codeRegion;
        const libelleRegion = requestParameters.libelleRegion;
        const codeTronconHydro = requestParameters.codeTronconHydro;
        const codeCoursEau = requestParameters.codeCoursEau;
        const libelleCoursEau = requestParameters.libelleCoursEau;
        const codeMasseEau = requestParameters.codeMasseEau;
        const libelleMasseEau = requestParameters.libelleMasseEau;
        const codeSousBassin = requestParameters.codeSousBassin;
        const libelleSousBassin = requestParameters.libelleSousBassin;
        const codeBassin = requestParameters.codeBassin;
        const libelleBassin = requestParameters.libelleBassin;
        const bbox = requestParameters.bbox;
        const size = requestParameters.size;
        const fields = requestParameters.fields;
        const page = requestParameters.page;
        const dateDebutMesure = requestParameters.dateDebutMesure;
        const dateFinMesure = requestParameters.dateFinMesure;
        const resultatMin = requestParameters.resultatMin;
        const resultatMax = requestParameters.resultatMax;
        const longitude = requestParameters.longitude;
        const latitude = requestParameters.latitude;
        const distance = requestParameters.distance;
        const sort = requestParameters.sort;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (codeStation) {
            codeStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_station');
            })
        }
        if (libelleStation) {
            libelleStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_station');
            })
        }
        if (codeCommune) {
            codeCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_commune');
            })
        }
        if (libelleCommune) {
            libelleCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_commune');
            })
        }
        if (codeDepartement) {
            codeDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_departement');
            })
        }
        if (libelleDepartement) {
            libelleDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_departement');
            })
        }
        if (codeRegion) {
            codeRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_region');
            })
        }
        if (libelleRegion) {
            libelleRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_region');
            })
        }
        if (codeTronconHydro) {
            codeTronconHydro.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_troncon_hydro');
            })
        }
        if (codeCoursEau) {
            codeCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_cours_eau');
            })
        }
        if (libelleCoursEau) {
            libelleCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_cours_eau');
            })
        }
        if (codeMasseEau) {
            codeMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_masse_eau');
            })
        }
        if (libelleMasseEau) {
            libelleMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_masse_eau');
            })
        }
        if (codeSousBassin) {
            codeSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_sous_bassin');
            })
        }
        if (libelleSousBassin) {
            libelleSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_sous_bassin');
            })
        }
        if (codeBassin) {
            codeBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_bassin');
            })
        }
        if (libelleBassin) {
            libelleBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_bassin');
            })
        }
        if (bbox) {
            bbox.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'bbox');
            })
        }
        if (size !== undefined && size !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>size, 'size');
        }
        if (fields !== undefined && fields !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>fields, 'fields');
        }
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (dateDebutMesure !== undefined && dateDebutMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateDebutMesure, 'date_debut_mesure');
        }
        if (dateFinMesure !== undefined && dateFinMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateFinMesure, 'date_fin_mesure');
        }
        if (resultatMin !== undefined && resultatMin !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resultatMin, 'resultat_min');
        }
        if (resultatMax !== undefined && resultatMax !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resultatMax, 'resultat_max');
        }
        if (longitude !== undefined && longitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>longitude, 'longitude');
        }
        if (latitude !== undefined && latitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>latitude, 'latitude');
        }
        if (distance !== undefined && distance !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>distance, 'distance');
        }
        if (sort !== undefined && sort !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sort, 'sort');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/csv'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<ChroniqueBE>(`${this.configuration.basePath}/v1/temperature/chronique.csv`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lister les stations de mesures de température au format CSV
     * Ce service permet de rechercher des stations de mesures  sur des cours d\&#39;eau et plan d\&#39;eau en France et les DROM.&lt;br/&gt;Source de données : Naïades est l\&#39;interface nationale pour l\&#39;accès aux données des rivières et des lacs. &lt;a href&#x3D;\&#39;http://naiades.eaufrance.fr/acces-donnees#/temperature\&#39; target&#x3D;\&#39;_blank\&#39;&gt;http://naiades.eaufrance.fr/acces-donnees#/temperature&lt;/a&gt;&lt;br/&gt;Si la valeur du paramètre size n\&#39;est pas renseignée, la taille de page par défaut : 1000, taille max de la page : 5000.&lt;br/&gt;La profondeur d\&#39;accès aux résultats est : 20000, calcul de la profondeur &#x3D; numéro de la page * nombre maximum de résultats dans une page.&lt;br/&gt;Trie par défaut : code_station asc
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stationCsv(requestParameters: StationCsvRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<StationBE>;
    public stationCsv(requestParameters: StationCsvRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<HttpResponse<StationBE>>;
    public stationCsv(requestParameters: StationCsvRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<HttpEvent<StationBE>>;
    public stationCsv(requestParameters: StationCsvRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/csv', context?: HttpContext}): Observable<any> {
        const codeStation = requestParameters.codeStation;
        const libelleStation = requestParameters.libelleStation;
        const codeCommune = requestParameters.codeCommune;
        const libelleCommune = requestParameters.libelleCommune;
        const codeDepartement = requestParameters.codeDepartement;
        const libelleDepartement = requestParameters.libelleDepartement;
        const codeRegion = requestParameters.codeRegion;
        const libelleRegion = requestParameters.libelleRegion;
        const codeTronconHydro = requestParameters.codeTronconHydro;
        const codeCoursEau = requestParameters.codeCoursEau;
        const libelleCoursEau = requestParameters.libelleCoursEau;
        const codeMasseEau = requestParameters.codeMasseEau;
        const libelleMasseEau = requestParameters.libelleMasseEau;
        const codeSousBassin = requestParameters.codeSousBassin;
        const libelleSousBassin = requestParameters.libelleSousBassin;
        const codeBassin = requestParameters.codeBassin;
        const libelleBassin = requestParameters.libelleBassin;
        const bbox = requestParameters.bbox;
        const size = requestParameters.size;
        const fields = requestParameters.fields;
        const page = requestParameters.page;
        const dateDebutMesure = requestParameters.dateDebutMesure;
        const dateFinMesure = requestParameters.dateFinMesure;
        const longitude = requestParameters.longitude;
        const latitude = requestParameters.latitude;
        const distance = requestParameters.distance;
        const exactCount = requestParameters.exactCount;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (codeStation) {
            codeStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_station');
            })
        }
        if (libelleStation) {
            libelleStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_station');
            })
        }
        if (codeCommune) {
            codeCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_commune');
            })
        }
        if (libelleCommune) {
            libelleCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_commune');
            })
        }
        if (codeDepartement) {
            codeDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_departement');
            })
        }
        if (libelleDepartement) {
            libelleDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_departement');
            })
        }
        if (codeRegion) {
            codeRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_region');
            })
        }
        if (libelleRegion) {
            libelleRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_region');
            })
        }
        if (codeTronconHydro) {
            codeTronconHydro.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_troncon_hydro');
            })
        }
        if (codeCoursEau) {
            codeCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_cours_eau');
            })
        }
        if (libelleCoursEau) {
            libelleCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_cours_eau');
            })
        }
        if (codeMasseEau) {
            codeMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_masse_eau');
            })
        }
        if (libelleMasseEau) {
            libelleMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_masse_eau');
            })
        }
        if (codeSousBassin) {
            codeSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_sous_bassin');
            })
        }
        if (libelleSousBassin) {
            libelleSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_sous_bassin');
            })
        }
        if (codeBassin) {
            codeBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_bassin');
            })
        }
        if (libelleBassin) {
            libelleBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_bassin');
            })
        }
        if (bbox) {
            bbox.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'bbox');
            })
        }
        if (size !== undefined && size !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>size, 'size');
        }
        if (fields !== undefined && fields !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>fields, 'fields');
        }
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (dateDebutMesure !== undefined && dateDebutMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateDebutMesure, 'date_debut_mesure');
        }
        if (dateFinMesure !== undefined && dateFinMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateFinMesure, 'date_fin_mesure');
        }
        if (longitude !== undefined && longitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>longitude, 'longitude');
        }
        if (latitude !== undefined && latitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>latitude, 'latitude');
        }
        if (distance !== undefined && distance !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>distance, 'distance');
        }
        if (exactCount !== undefined && exactCount !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>exactCount, 'exact_count');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'text/csv'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<StationBE>(`${this.configuration.basePath}/v1/temperature/station.csv`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Lister les stations de mesures de température
     * Ce service permet de rechercher des stations de mesures  sur des cours d\&#39;eau et plan d\&#39;eau en France et les DROM.&lt;br/&gt;Source de données : Naïades est l\&#39;interface nationale pour l\&#39;accès aux données des rivières et des lacs. &lt;a href&#x3D;\&#39;http://naiades.eaufrance.fr/acces-donnees#/temperature\&#39; target&#x3D;\&#39;_blank\&#39;&gt;http://naiades.eaufrance.fr/acces-donnees#/temperature&lt;/a&gt;&lt;br/&gt;Si la valeur du paramètre size n\&#39;est pas renseignée, la taille de page par défaut : 1000, taille max de la page : 5000.&lt;br/&gt;La profondeur d\&#39;accès aux résultats est : 20000, calcul de la profondeur &#x3D; numéro de la page * nombre maximum de résultats dans une page.&lt;br/&gt;Trie par défaut : code_station asc
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stations(requestParameters: StationsRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.geo+json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<Rsultat dune rquete sur les stationsBE>;
    public stations(requestParameters: StationsRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.geo+json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<HttpResponse<Rsultat dune rquete sur les stationsBE>>;
    public stations(requestParameters: StationsRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.geo+json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<HttpEvent<Rsultat dune rquete sur les stationsBE>>;
    public stations(requestParameters: StationsRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/vnd.geo+json' | 'application/javascript;charset&#x3D;UTF-8', context?: HttpContext}): Observable<any> {
        const codeStation = requestParameters.codeStation;
        const libelleStation = requestParameters.libelleStation;
        const codeCommune = requestParameters.codeCommune;
        const libelleCommune = requestParameters.libelleCommune;
        const codeDepartement = requestParameters.codeDepartement;
        const libelleDepartement = requestParameters.libelleDepartement;
        const codeRegion = requestParameters.codeRegion;
        const libelleRegion = requestParameters.libelleRegion;
        const codeTronconHydro = requestParameters.codeTronconHydro;
        const codeCoursEau = requestParameters.codeCoursEau;
        const libelleCoursEau = requestParameters.libelleCoursEau;
        const codeMasseEau = requestParameters.codeMasseEau;
        const libelleMasseEau = requestParameters.libelleMasseEau;
        const codeSousBassin = requestParameters.codeSousBassin;
        const libelleSousBassin = requestParameters.libelleSousBassin;
        const codeBassin = requestParameters.codeBassin;
        const libelleBassin = requestParameters.libelleBassin;
        const bbox = requestParameters.bbox;
        const size = requestParameters.size;
        const fields = requestParameters.fields;
        const page = requestParameters.page;
        const dateDebutMesure = requestParameters.dateDebutMesure;
        const dateFinMesure = requestParameters.dateFinMesure;
        const longitude = requestParameters.longitude;
        const latitude = requestParameters.latitude;
        const distance = requestParameters.distance;
        const exactCount = requestParameters.exactCount;
        const format = requestParameters.format;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (codeStation) {
            codeStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_station');
            })
        }
        if (libelleStation) {
            libelleStation.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_station');
            })
        }
        if (codeCommune) {
            codeCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_commune');
            })
        }
        if (libelleCommune) {
            libelleCommune.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_commune');
            })
        }
        if (codeDepartement) {
            codeDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_departement');
            })
        }
        if (libelleDepartement) {
            libelleDepartement.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_departement');
            })
        }
        if (codeRegion) {
            codeRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_region');
            })
        }
        if (libelleRegion) {
            libelleRegion.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_region');
            })
        }
        if (codeTronconHydro) {
            codeTronconHydro.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_troncon_hydro');
            })
        }
        if (codeCoursEau) {
            codeCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_cours_eau');
            })
        }
        if (libelleCoursEau) {
            libelleCoursEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_cours_eau');
            })
        }
        if (codeMasseEau) {
            codeMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_masse_eau');
            })
        }
        if (libelleMasseEau) {
            libelleMasseEau.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_masse_eau');
            })
        }
        if (codeSousBassin) {
            codeSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_sous_bassin');
            })
        }
        if (libelleSousBassin) {
            libelleSousBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_sous_bassin');
            })
        }
        if (codeBassin) {
            codeBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'code_bassin');
            })
        }
        if (libelleBassin) {
            libelleBassin.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'libelle_bassin');
            })
        }
        if (bbox) {
            bbox.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'bbox');
            })
        }
        if (size !== undefined && size !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>size, 'size');
        }
        if (fields !== undefined && fields !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>fields, 'fields');
        }
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (dateDebutMesure !== undefined && dateDebutMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateDebutMesure, 'date_debut_mesure');
        }
        if (dateFinMesure !== undefined && dateFinMesure !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dateFinMesure, 'date_fin_mesure');
        }
        if (longitude !== undefined && longitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>longitude, 'longitude');
        }
        if (latitude !== undefined && latitude !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>latitude, 'latitude');
        }
        if (distance !== undefined && distance !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>distance, 'distance');
        }
        if (exactCount !== undefined && exactCount !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>exactCount, 'exact_count');
        }
        if (format !== undefined && format !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>format, 'format');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json',
                'application/vnd.geo+json',
                'application/javascript;charset=UTF-8'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<Rsultat dune rquete sur les stationsBE>(`${this.configuration.basePath}/v1/temperature/station`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
