/**
 * PCB API
 * This Web site allows you to learn and test our PCB API.  **What’s new**:   * **Content: GET {cultureCode}/{oid}/contents : Add fallback for LNK content type: generate LNK data for level 5 oid from their filtered level 7**   * Add new option “exactSearch” for the endpoint Catalog : GET /{cultureCode}/search/autocomplete/{term}      * Add new option “fallback” to improve research on ppimage4online for endpoint :    * Content: GET /{cultureCode}/{oid}/ppimage4online    * Content: POST /{cultureCode}/oids/ppimage4online    * Content type HST returns new field “crestSort” to specify if a companion is Top Recommended for an Host’s product (we recommend to use ‘crestsort’ instead of ‘recommended’)   * Content type HST returns new fields “level5oid”, “level5name” for each Host’s Product to provide Series\' information   * Content type HST returns new branches with the list of Host Series (option: ShowHostSeries): HST_SERIES_OIDS and HST_SERIES    * Add new parameter “hidePath” and “filter” for endpoints: * Content: POST /{cultureCode}/products/contents * Content: POST /{cultureCode}/oids/contents   * Content type LNK returns new field “crestSort” to specify if the companion is Top recommended or not   * Retrieve the primary product image for online purpose * Content: GET /{cultureCode}/{oid}/ppimage4online * Content: POST /{cultureCode}/oids/ppimage4online   * *AUTOCOMPLETE works with localized prodname*  * *Content type VID provides Video – Animation in addition of Video corporate and Product Overview*  * New API route * Content: POST /{cultureCode}/oids/contents returns the contents of multiple node according to given cultureCode, statuses and content types  * Provide Product Line information at SKU Level  * Provide PLC information on product for all catalogues:  * Content: GET /{cultureCode}/{oid}/contents (contentType: MDA) * Content: GET /{cultureCode}/products/{productNumber}/contents (contentType: MDA)  * Catalog: GET /{cultureCode}/search/autocomplete/{term} add new parameters ‘productPatterns’, ‘includedBranchHeadOids’, ‘excludedBranchHeadOids’  * Catalog: GET /{cultureCode}/{oid}/productNumbers add new parameter ‘productPatterns’  * Add new type of content (RC) Recommended Companions for: * Catalog: GET /{cultureCode}/{oid}/contents * Catalog: GET /{cultureCode}/products/{productNumber}/contents  **Requests identification & authorization**:  All the requests to the PCB API *must* be identified using at least one token. There are two kinds of tokens:  * The **Application Token** which helps to identity which application is using the API (e.g. PCB, Swagger, ...). This token, if present, must be put in the `X-Application-Token` HTTP header for each request made to the API. In order to connect your application to the API, you need an application token. You can request one at http://hppcb.freshdesk.com/support/home * The **User Token** which are specific to user, whatever application they\'re using. The token contains user information + active permissions, for instance the right to see pre-release products. These tokens are conventionally not disclosed to the end users, but rather used by applications (e.g. via a login form). This token, if present, must be put in the `Authentication` HTTP header for each request, using the [Bearer Authentication](https://swagger.io/docs/specification/authentication/bearer-authentication) convention. If you hold your user token, you can use it in Swagger using the *\"Authorize\"* button (referred as \'api_key)\'.   The API will refuse any request that: * Does not hold any application **or** user token. * Provide tokens that are malformed, invalid or expired.  Through this swagger web site, you **should not use a token application** (swagger has its own).  **In Case of problem to access PCB API**, please submit a ticket through the URL:  http://hppcb.freshdesk.com/support/tickets/new  **Information about common types**: * **Node status** (updated once a day)  * L (Live)  * O (Obsolete)  * F (Future/pre-released)  * **Culture code / Catalog** :  * matches __[a-z]{2}-[a-z]{2}__.  e.g. ww-en, us-en,... Full list at **_/catalogs**  * **Content type**  * MSG (messaging)  * TSP (tech specs)  * SYS (system)  * LOG  * PIC  * OTH  * IMG (images urls, with metadatas)   * DOC (documents urls like TechSpecs, ...)   * LNK (linked products, compatibilities, ...)   * HST (companion\'s hosts)   * VID (videos)   * RAT (Ratings Data)   * MDA (Meta Data, PLC Date)    * RC (Recommended Companions)  * **Hierarchy paradigm**  * Q, Quick : **Level1/Product Category** -> **Level5/Serie** -> **Level7/SKU**  * F, Full: All levels
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { CatalogBE } from '../model/catalog';
// @ts-ignore
import { NodeInCultureBE } from '../model/nodeInCulture';
// @ts-ignore
import { NodeInCultureWithChildrenBE } from '../model/nodeInCultureWithChildren';
// @ts-ignore
import { NodeProductsBE } from '../model/nodeProducts';
// @ts-ignore
import { NodeSearchResultsBE } from '../model/nodeSearchResults';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


export interface CultureCodeOidChildrenGetRequestParams {
    cultureCode: string;
    oid: string;
    hierarchyParadigm: 'F' | 'Q';
    status?: Set<'L' | 'O' | 'F'>;
}

export interface CultureCodeOidGetRequestParams {
    cultureCode: string;
    oid: string;
    status?: Set<'L' | 'O' | 'F'>;
}

export interface CultureCodeOidProductNumbersGetRequestParams {
    cultureCode: string;
    oid: string;
    pageNumber: number;
    status?: Set<'L' | 'O' | 'F'>;
    /** A list of regular expressions that restrict level 7 term-matching nodes to the ones with product number matching one of the expressions.   E.g.: (DUM.*) include all level 7 nodes with product number starting with \&quot;DUM\&quot;   ~(DUM.*) excludes all level 7 nodes with product number starting with \&quot;DUM\&quot; */
    productPatterns?: Array<string>;
}

export interface CultureCodeSearchAutocompleteTermGetRequestParams {
    cultureCode: string;
    term: string;
    searchModes: Set<'product' | 'codename'>;
    searchLimit: number;
    status?: Set<'L' | 'O' | 'F'>;
    /** A list of parent OIDs to exclude. When a term-matching node is &lt;i&gt;under&lt;/i&gt; one of the given OIDs, it is excluded. This parameters has a high priority than includedBranchHeadOids */
    excludedBranchHeadOids?: Array<number>;
    /** A list of parent OIDs to restrict too. When a term-matching node is &lt;i&gt;under&lt;/i&gt; one of the given OIDs, it is included (except if excluded due to excludedBranchHeadOids) */
    includedBranchHeadOids?: Array<number>;
    /** A list of regular expressions that restrict level 7 term-matching nodes to the ones with product number matching one of the expressions.   E.g.: (DUM.*) include all level 7 nodes with product number starting with \&quot;DUM\&quot;   ~(DUM.*) excludes all level 7 nodes with product number starting with \&quot;DUM\&quot; */
    productPatterns?: Array<string>;
    /** Enable to exclude empty series */
    excludeEmptySeries?: boolean;
    /** Enable to search on default name ww-en (no parameter or false), or on translated name linked to culture code (true) */
    searchOnTranslatedName?: boolean;
    /** Set the exactSearch to ‘true’ to consider the term as a unique string (Space is not a delimiter). */
    exactSearch?: boolean;
}


@Injectable({
  providedIn: 'root'
})
export class CatalogService {

    protected basePath = 'https://pcbapi.inc.hp.com/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * List existing catalogs (culture codes)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public catalogsGet(observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<{ [key: string]: CatalogBE; }>;
    public catalogsGet(observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<{ [key: string]: CatalogBE; }>>;
    public catalogsGet(observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<{ [key: string]: CatalogBE; }>>;
    public catalogsGet(observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<{ [key: string]: CatalogBE; }>(`${this.configuration.basePath}/catalogs`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List children of a node
     * Get children of given node (oid) in given catalog, with given statuses.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidChildrenGet(requestParameters: CultureCodeOidChildrenGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeInCultureWithChildrenBE>;
    public cultureCodeOidChildrenGet(requestParameters: CultureCodeOidChildrenGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeInCultureWithChildrenBE>>;
    public cultureCodeOidChildrenGet(requestParameters: CultureCodeOidChildrenGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeInCultureWithChildrenBE>>;
    public cultureCodeOidChildrenGet(requestParameters: CultureCodeOidChildrenGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidChildrenGet.');
        }
        const oid = requestParameters.oid;
        if (oid === null || oid === undefined) {
            throw new Error('Required parameter oid was null or undefined when calling cultureCodeOidChildrenGet.');
        }
        const hierarchyParadigm = requestParameters.hierarchyParadigm;
        if (hierarchyParadigm === null || hierarchyParadigm === undefined) {
            throw new Error('Required parameter hierarchyParadigm was null or undefined when calling cultureCodeOidChildrenGet.');
        }
        const status = requestParameters.status;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (hierarchyParadigm !== undefined && hierarchyParadigm !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>hierarchyParadigm, 'hierarchyParadigm');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeInCultureWithChildrenBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/${encodeURIComponent(String(oid))}/children`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Check oid existance
     *  Check if given oid exists with given statuses in given catalogs. If true, gets its path
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidGet(requestParameters: CultureCodeOidGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeInCultureBE>;
    public cultureCodeOidGet(requestParameters: CultureCodeOidGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeInCultureBE>>;
    public cultureCodeOidGet(requestParameters: CultureCodeOidGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeInCultureBE>>;
    public cultureCodeOidGet(requestParameters: CultureCodeOidGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidGet.');
        }
        const oid = requestParameters.oid;
        if (oid === null || oid === undefined) {
            throw new Error('Required parameter oid was null or undefined when calling cultureCodeOidGet.');
        }
        const status = requestParameters.status;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeInCultureBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/${encodeURIComponent(String(oid))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List product numbers belonging the a given branch
     * Get the products numbers located in the catalog branch whose tip is the given node, with given statuses.   Use the productPatterns parameter to restrict ** level 7 nodes ** by regular expressions on their product number (all of them). Expressions can be negated in order to exclude certain products  * E.g. Dummy products have prodnum starting with \&#39;DUM\&#39; : \&#39;__DUM.*__\&#39; include all of them  * E.g. Refurbish products have prodnum finishing with an \&#39;R\&#39;: \&#39;__.*R__\&#39; exclude all of them  * E.g. CTO products have prodnum finishing with \&#39;AV\&#39; : \&#39;__.*AV__\&#39; include all of them  * E.g. PCCS SKUs where prodnum is ending by: UP, UC, US , EP, EC, ES, LP, LC, LS, PP, PC, PS : \&#39;__~(.*[UELP][PCS])__\&#39; exlude all of them  * E.g. Using both \&#39;__~(K.* )__\&#39; and \&#39;__.{9}__ \&#39; will return only level 7 nodes with product numbers of 9 chars and not starting with \&#39;K\&#39;.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidProductNumbersGet(requestParameters: CultureCodeOidProductNumbersGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeProductsBE>;
    public cultureCodeOidProductNumbersGet(requestParameters: CultureCodeOidProductNumbersGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeProductsBE>>;
    public cultureCodeOidProductNumbersGet(requestParameters: CultureCodeOidProductNumbersGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeProductsBE>>;
    public cultureCodeOidProductNumbersGet(requestParameters: CultureCodeOidProductNumbersGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidProductNumbersGet.');
        }
        const oid = requestParameters.oid;
        if (oid === null || oid === undefined) {
            throw new Error('Required parameter oid was null or undefined when calling cultureCodeOidProductNumbersGet.');
        }
        const pageNumber = requestParameters.pageNumber;
        if (pageNumber === null || pageNumber === undefined) {
            throw new Error('Required parameter pageNumber was null or undefined when calling cultureCodeOidProductNumbersGet.');
        }
        const status = requestParameters.status;
        const productPatterns = requestParameters.productPatterns;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (pageNumber !== undefined && pageNumber !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>pageNumber, 'pageNumber');
        }
        if (productPatterns) {
            productPatterns.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'productPatterns[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeProductsBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/${encodeURIComponent(String(oid))}/productNumbers`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for Series/SKU
     * Term-based search of Series and SKUs in given catalog with given statuses. Terms can match on Series names and/or codenames on Series Level (Level 5) and product name and product number (Level7). Level 5 (Series) are returned first.   We can now search on prodname in **non-English** languages.    Following parameters helps in overfiltering term-matching nodes:  * Use exactSearch &#x3D; “true” to not consider the “space” character as a delimiter in the term (eg: with the string ‘HP 80’, PCB is searching Series/SKUs containing “HP 80” for the selected SearchModes) If exactSearch &#x3D; “false” or not used at all (backward compatibility), the “space” character is considered as a delimiter (eg: with the string ‘HP 80’, PCB is searching all Series/SKUs containing “HP” and “80” for the selected SearchModes)   * Use the includedBranchHeadOids parameter to restrict the search to a particular set of branches of the hierachy  * Use the exludedBranchHeadOids parameter to exclude a set of branches of the hierachy. This exclusion has a **higest priority** than includedBranchHeadOids  * Use the productPatterns parameter to restrict ** level 7 nodes ** by regular expressions on their product number (all of them). Expressions can be negated in order to exclude certain products    * E.g. Dummy products have prodnum starting with \&#39;DUM\&#39; : \&#39;__DUM.*__\&#39; include all of them    * E.g. Refurbish products have prodnum finishing with an \&#39;R\&#39;: \&#39;__~(.*R)__\&#39; exclude all of them    * E.g. CTO products have prodnum finishing with \&#39;AV\&#39; : \&#39;__.*AV__\&#39;  include all of them    * E.g. PCCS SKUs where prodnum is ending by: UP, UC, US , EP, EC, ES, LP, LC, LS, PP, PC, PS : \&#39;__~(.*[UELP][PCS])__\&#39; exclude all of them    * E.g. Using both \&#39;~(__K.*__)\&#39; and \&#39;__.{9}__\&#39; will return only level 7 nodes with product numbers of 9 chars and not starting with \&#39;K\&#39;     This does not affect the level 5 nodes filter.  * Use the excludeEmptySeries to exclude or not the empty series from the result   Following parameter helps to provide additional information:  * Use the searchOnTranslatedName to retrieve localized prodname in addition of the english prodname
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeSearchAutocompleteTermGet(requestParameters: CultureCodeSearchAutocompleteTermGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeSearchResultsBE>;
    public cultureCodeSearchAutocompleteTermGet(requestParameters: CultureCodeSearchAutocompleteTermGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeSearchResultsBE>>;
    public cultureCodeSearchAutocompleteTermGet(requestParameters: CultureCodeSearchAutocompleteTermGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeSearchResultsBE>>;
    public cultureCodeSearchAutocompleteTermGet(requestParameters: CultureCodeSearchAutocompleteTermGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeSearchAutocompleteTermGet.');
        }
        const term = requestParameters.term;
        if (term === null || term === undefined) {
            throw new Error('Required parameter term was null or undefined when calling cultureCodeSearchAutocompleteTermGet.');
        }
        const searchModes = requestParameters.searchModes;
        if (searchModes === null || searchModes === undefined) {
            throw new Error('Required parameter searchModes was null or undefined when calling cultureCodeSearchAutocompleteTermGet.');
        }
        const searchLimit = requestParameters.searchLimit;
        if (searchLimit === null || searchLimit === undefined) {
            throw new Error('Required parameter searchLimit was null or undefined when calling cultureCodeSearchAutocompleteTermGet.');
        }
        const status = requestParameters.status;
        const excludedBranchHeadOids = requestParameters.excludedBranchHeadOids;
        const includedBranchHeadOids = requestParameters.includedBranchHeadOids;
        const productPatterns = requestParameters.productPatterns;
        const excludeEmptySeries = requestParameters.excludeEmptySeries;
        const searchOnTranslatedName = requestParameters.searchOnTranslatedName;
        const exactSearch = requestParameters.exactSearch;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (searchModes) {
            searchModes.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'searchModes[]');
            })
        }
        if (excludedBranchHeadOids) {
            excludedBranchHeadOids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'excludedBranchHeadOids[]');
            })
        }
        if (includedBranchHeadOids) {
            includedBranchHeadOids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'includedBranchHeadOids[]');
            })
        }
        if (productPatterns) {
            productPatterns.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'productPatterns[]');
            })
        }
        if (searchLimit !== undefined && searchLimit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchLimit, 'searchLimit');
        }
        if (excludeEmptySeries !== undefined && excludeEmptySeries !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>excludeEmptySeries, 'excludeEmptySeries');
        }
        if (searchOnTranslatedName !== undefined && searchOnTranslatedName !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchOnTranslatedName, 'searchOnTranslatedName');
        }
        if (exactSearch !== undefined && exactSearch !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>exactSearch, 'exactSearch');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeSearchResultsBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/search/autocomplete/${encodeURIComponent(String(term))}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
