/**
 * PCB API
 * This Web site allows you to learn and test our PCB API.  **What’s new**:   * **Content: GET {cultureCode}/{oid}/contents : Add fallback for LNK content type: generate LNK data for level 5 oid from their filtered level 7**   * Add new option “exactSearch” for the endpoint Catalog : GET /{cultureCode}/search/autocomplete/{term}      * Add new option “fallback” to improve research on ppimage4online for endpoint :    * Content: GET /{cultureCode}/{oid}/ppimage4online    * Content: POST /{cultureCode}/oids/ppimage4online    * Content type HST returns new field “crestSort” to specify if a companion is Top Recommended for an Host’s product (we recommend to use ‘crestsort’ instead of ‘recommended’)   * Content type HST returns new fields “level5oid”, “level5name” for each Host’s Product to provide Series\' information   * Content type HST returns new branches with the list of Host Series (option: ShowHostSeries): HST_SERIES_OIDS and HST_SERIES    * Add new parameter “hidePath” and “filter” for endpoints: * Content: POST /{cultureCode}/products/contents * Content: POST /{cultureCode}/oids/contents   * Content type LNK returns new field “crestSort” to specify if the companion is Top recommended or not   * Retrieve the primary product image for online purpose * Content: GET /{cultureCode}/{oid}/ppimage4online * Content: POST /{cultureCode}/oids/ppimage4online   * *AUTOCOMPLETE works with localized prodname*  * *Content type VID provides Video – Animation in addition of Video corporate and Product Overview*  * New API route * Content: POST /{cultureCode}/oids/contents returns the contents of multiple node according to given cultureCode, statuses and content types  * Provide Product Line information at SKU Level  * Provide PLC information on product for all catalogues:  * Content: GET /{cultureCode}/{oid}/contents (contentType: MDA) * Content: GET /{cultureCode}/products/{productNumber}/contents (contentType: MDA)  * Catalog: GET /{cultureCode}/search/autocomplete/{term} add new parameters ‘productPatterns’, ‘includedBranchHeadOids’, ‘excludedBranchHeadOids’  * Catalog: GET /{cultureCode}/{oid}/productNumbers add new parameter ‘productPatterns’  * Add new type of content (RC) Recommended Companions for: * Catalog: GET /{cultureCode}/{oid}/contents * Catalog: GET /{cultureCode}/products/{productNumber}/contents  **Requests identification & authorization**:  All the requests to the PCB API *must* be identified using at least one token. There are two kinds of tokens:  * The **Application Token** which helps to identity which application is using the API (e.g. PCB, Swagger, ...). This token, if present, must be put in the `X-Application-Token` HTTP header for each request made to the API. In order to connect your application to the API, you need an application token. You can request one at http://hppcb.freshdesk.com/support/home * The **User Token** which are specific to user, whatever application they\'re using. The token contains user information + active permissions, for instance the right to see pre-release products. These tokens are conventionally not disclosed to the end users, but rather used by applications (e.g. via a login form). This token, if present, must be put in the `Authentication` HTTP header for each request, using the [Bearer Authentication](https://swagger.io/docs/specification/authentication/bearer-authentication) convention. If you hold your user token, you can use it in Swagger using the *\"Authorize\"* button (referred as \'api_key)\'.   The API will refuse any request that: * Does not hold any application **or** user token. * Provide tokens that are malformed, invalid or expired.  Through this swagger web site, you **should not use a token application** (swagger has its own).  **In Case of problem to access PCB API**, please submit a ticket through the URL:  http://hppcb.freshdesk.com/support/tickets/new  **Information about common types**: * **Node status** (updated once a day)  * L (Live)  * O (Obsolete)  * F (Future/pre-released)  * **Culture code / Catalog** :  * matches __[a-z]{2}-[a-z]{2}__.  e.g. ww-en, us-en,... Full list at **_/catalogs**  * **Content type**  * MSG (messaging)  * TSP (tech specs)  * SYS (system)  * LOG  * PIC  * OTH  * IMG (images urls, with metadatas)   * DOC (documents urls like TechSpecs, ...)   * LNK (linked products, compatibilities, ...)   * HST (companion\'s hosts)   * VID (videos)   * RAT (Ratings Data)   * MDA (Meta Data, PLC Date)    * RC (Recommended Companions)  * **Hierarchy paradigm**  * Q, Quick : **Level1/Product Category** -> **Level5/Serie** -> **Level7/SKU**  * F, Full: All levels
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { NodeInCultureWithContentBE } from '../model/nodeInCultureWithContent';
// @ts-ignore
import { NodeWithTranslatedContentsBE } from '../model/nodeWithTranslatedContents';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


export interface CultureCodeOidContentsGetRequestParams {
    cultureCode: string;
    oid: string;
    contentType: Set<'TSP' | 'MSG' | 'SYS' | 'LOG' | 'PIC' | 'IMG' | 'DOC' | 'OTH' | 'LNK' | 'HST' | 'VID' | 'RAT' | 'MDA' | 'RC'>;
    status?: Set<'L' | 'O' | 'F'>;
    /** Optional.  showHostsSeries:  - applicable for HST content type only - use it to list series informations for HST */
    options?: Set<'showHostSeries'>;
}

export interface CultureCodeOidPpimage4onlineGetRequestParams {
    cultureCode: string;
    oid: string;
    status?: Set<'L' | 'O' | 'F'>;
    /** Optional.  fallback:  - Apply fallback rules when no image is available for the selected OID If product (level 7) then search image on the parent (level 6) and other similar products If level 6, 5 and 4 then search image on associated products */
    options?: Set<'fallback'>;
}

export interface CultureCodeOidTranslatedContentsGetRequestParams {
    cultureCode: string;
    oid: string;
    contentType: Set<'TSP' | 'MSG' | 'SYS' | 'LOG' | 'PIC' | 'OTH'>;
    cultureCodes: Set<string>;
    status?: Set<'L' | 'O' | 'F'>;
}

export interface CultureCodeOidsContentsPostRequestParams {
    cultureCode: string;
    contentType: Set<'TSP' | 'MSG' | 'SYS' | 'LOG' | 'PIC' | 'IMG' | 'DOC' | 'OTH' | 'RAT' | 'MDA'>;
    oids: Array<number>;
    status?: Set<'L' | 'O' | 'F'>;
    /** Enable to remove hierarchy of a product (path block) */
    hidePath?: boolean;
    /** Optional. If you specify a filter for one content type you need to specify for all selected content types.   Path starts from the content block. Separator for level is the pipe symbol |. Wildcard can be used (ex: MSG|headline\\* returns content for all fields with name starts with headline) (ex: MSG|\\* returns all content type data for MSG) */
    filter?: Set<string>;
}

export interface CultureCodeOidsPpimage4onlinePostRequestParams {
    cultureCode: string;
    oids: Array<number>;
    status?: Set<'L' | 'O' | 'F'>;
    /** Optional.  fallback:  - Apply fallback rules when no image is available for the selected OID If product (level 7) then search image on the parent (level 6) and other similar products If level 6, 5 and 4 then search image on associated products */
    options?: Set<'fallback'>;
}

export interface CultureCodeProductsContentsPostRequestParams {
    cultureCode: string;
    contentType: Set<'TSP' | 'MSG' | 'SYS' | 'LOG' | 'PIC' | 'IMG' | 'DOC' | 'OTH' | 'RAT' | 'MDA'>;
    productNumbers: Array<string>;
    status?: Set<'L' | 'O' | 'F'>;
    /** Enable to remove hierarchy of a product (path block) */
    hidePath?: boolean;
    /** Optional. If you specify a filter for one content type you need to specify for all selected content types.   Path starts from the content block. Separator for level is the pipe symbol |. Wildcard can be used (ex: MSG|headline\\* returns content for all fields with name starts with headline) (ex: MSG|\\* returns all content type data for MSG) */
    filter?: Set<string>;
}

export interface CultureCodeProductsProductNumberContentsGetRequestParams {
    cultureCode: string;
    productNumber: string;
    contentType: Set<'TSP' | 'MSG' | 'SYS' | 'LOG' | 'PIC' | 'IMG' | 'DOC' | 'OTH' | 'LNK' | 'HST' | 'VID' | 'RAT' | 'MDA' | 'RC'>;
    status?: Set<'L' | 'O' | 'F'>;
    /** Optional.  showHostsSeries:  - applicable for HST content type only - use it to list series informations for HST */
    options?: Set<'showHostSeries'>;
}


@Injectable({
  providedIn: 'root'
})
export class ContentsService {

    protected basePath = 'https://pcbapi.inc.hp.com/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get contents for a single node
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidContentsGet(requestParameters: CultureCodeOidContentsGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeInCultureWithContentBE>;
    public cultureCodeOidContentsGet(requestParameters: CultureCodeOidContentsGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeInCultureWithContentBE>>;
    public cultureCodeOidContentsGet(requestParameters: CultureCodeOidContentsGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeInCultureWithContentBE>>;
    public cultureCodeOidContentsGet(requestParameters: CultureCodeOidContentsGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidContentsGet.');
        }
        const oid = requestParameters.oid;
        if (oid === null || oid === undefined) {
            throw new Error('Required parameter oid was null or undefined when calling cultureCodeOidContentsGet.');
        }
        const contentType = requestParameters.contentType;
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cultureCodeOidContentsGet.');
        }
        const status = requestParameters.status;
        const options = requestParameters.options;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (contentType) {
            contentType.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'contentType[]');
            })
        }
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (options) {
            options.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'options[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Bearer) required
        localVarCredential = this.configuration.lookupCredential('Bearer');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeInCultureWithContentBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/${encodeURIComponent(String(oid))}/contents`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get primary product image for online purpose for a single node
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidPpimage4onlineGet(requestParameters: CultureCodeOidPpimage4onlineGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeInCultureWithContentBE>;
    public cultureCodeOidPpimage4onlineGet(requestParameters: CultureCodeOidPpimage4onlineGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeInCultureWithContentBE>>;
    public cultureCodeOidPpimage4onlineGet(requestParameters: CultureCodeOidPpimage4onlineGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeInCultureWithContentBE>>;
    public cultureCodeOidPpimage4onlineGet(requestParameters: CultureCodeOidPpimage4onlineGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidPpimage4onlineGet.');
        }
        const oid = requestParameters.oid;
        if (oid === null || oid === undefined) {
            throw new Error('Required parameter oid was null or undefined when calling cultureCodeOidPpimage4onlineGet.');
        }
        const status = requestParameters.status;
        const options = requestParameters.options;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (options) {
            options.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'options[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Bearer) required
        localVarCredential = this.configuration.lookupCredential('Bearer');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeInCultureWithContentBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/${encodeURIComponent(String(oid))}/ppimage4online`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contents from multiple catalogs
     * Gets contents (of given contentTypes) for the given node (oid) (exstining in the given cultureCode and statuses) translated into given cultureCodes. Status of node in target catalogs is not checked 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidTranslatedContentsGet(requestParameters: CultureCodeOidTranslatedContentsGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeWithTranslatedContentsBE>;
    public cultureCodeOidTranslatedContentsGet(requestParameters: CultureCodeOidTranslatedContentsGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeWithTranslatedContentsBE>>;
    public cultureCodeOidTranslatedContentsGet(requestParameters: CultureCodeOidTranslatedContentsGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeWithTranslatedContentsBE>>;
    public cultureCodeOidTranslatedContentsGet(requestParameters: CultureCodeOidTranslatedContentsGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidTranslatedContentsGet.');
        }
        const oid = requestParameters.oid;
        if (oid === null || oid === undefined) {
            throw new Error('Required parameter oid was null or undefined when calling cultureCodeOidTranslatedContentsGet.');
        }
        const contentType = requestParameters.contentType;
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cultureCodeOidTranslatedContentsGet.');
        }
        const cultureCodes = requestParameters.cultureCodes;
        if (cultureCodes === null || cultureCodes === undefined) {
            throw new Error('Required parameter cultureCodes was null or undefined when calling cultureCodeOidTranslatedContentsGet.');
        }
        const status = requestParameters.status;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (contentType) {
            contentType.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'contentType[]');
            })
        }
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (cultureCodes) {
            cultureCodes.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'cultureCodes[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeWithTranslatedContentsBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/${encodeURIComponent(String(oid))}/translatedContents`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contents for multiple nodes
     * Returns the contents of multiple node according to given cultureCode, statuses and content types. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidsContentsPost(requestParameters: CultureCodeOidsContentsPostRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<{ [key: string]: NodeInCultureWithContentBE; }>;
    public cultureCodeOidsContentsPost(requestParameters: CultureCodeOidsContentsPostRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<{ [key: string]: NodeInCultureWithContentBE; }>>;
    public cultureCodeOidsContentsPost(requestParameters: CultureCodeOidsContentsPostRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<{ [key: string]: NodeInCultureWithContentBE; }>>;
    public cultureCodeOidsContentsPost(requestParameters: CultureCodeOidsContentsPostRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidsContentsPost.');
        }
        const contentType = requestParameters.contentType;
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cultureCodeOidsContentsPost.');
        }
        const oids = requestParameters.oids;
        if (oids === null || oids === undefined) {
            throw new Error('Required parameter oids was null or undefined when calling cultureCodeOidsContentsPost.');
        }
        const status = requestParameters.status;
        const hidePath = requestParameters.hidePath;
        const filter = requestParameters.filter;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (contentType) {
            contentType.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'contentType[]');
            })
        }
        if (hidePath !== undefined && hidePath !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>hidePath, 'hidePath');
        }
        if (filter) {
            filter.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-www-form-urlencoded'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (oids) {
            if (localVarUseForm) {
                oids.forEach((element) => {
                    localVarFormParams = localVarFormParams.append('oids[]', <any>element) as any || localVarFormParams;
            })
            } else {
                localVarFormParams = localVarFormParams.append('oids[]', oids.join(COLLECTION_FORMATS['csv'])) as any || localVarFormParams;
            }
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<{ [key: string]: NodeInCultureWithContentBE; }>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/oids/contents`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get primary image for multiple nodes
     * Returns the primary product image for online purpose of multiple node according to given cultureCode and statuses. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeOidsPpimage4onlinePost(requestParameters: CultureCodeOidsPpimage4onlinePostRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<{ [key: string]: NodeInCultureWithContentBE; }>;
    public cultureCodeOidsPpimage4onlinePost(requestParameters: CultureCodeOidsPpimage4onlinePostRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<{ [key: string]: NodeInCultureWithContentBE; }>>;
    public cultureCodeOidsPpimage4onlinePost(requestParameters: CultureCodeOidsPpimage4onlinePostRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<{ [key: string]: NodeInCultureWithContentBE; }>>;
    public cultureCodeOidsPpimage4onlinePost(requestParameters: CultureCodeOidsPpimage4onlinePostRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeOidsPpimage4onlinePost.');
        }
        const oids = requestParameters.oids;
        if (oids === null || oids === undefined) {
            throw new Error('Required parameter oids was null or undefined when calling cultureCodeOidsPpimage4onlinePost.');
        }
        const status = requestParameters.status;
        const options = requestParameters.options;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (options) {
            options.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'options[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-www-form-urlencoded'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (oids) {
            if (localVarUseForm) {
                oids.forEach((element) => {
                    localVarFormParams = localVarFormParams.append('oids[]', <any>element) as any || localVarFormParams;
            })
            } else {
                localVarFormParams = localVarFormParams.append('oids[]', oids.join(COLLECTION_FORMATS['csv'])) as any || localVarFormParams;
            }
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<{ [key: string]: NodeInCultureWithContentBE; }>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/oids/ppimage4online`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contents for multiple SKUs
     * Returns the contents of multiple sku according to given cultureCode, statuses and content types. 
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeProductsContentsPost(requestParameters: CultureCodeProductsContentsPostRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<{ [key: string]: NodeInCultureWithContentBE; }>;
    public cultureCodeProductsContentsPost(requestParameters: CultureCodeProductsContentsPostRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<{ [key: string]: NodeInCultureWithContentBE; }>>;
    public cultureCodeProductsContentsPost(requestParameters: CultureCodeProductsContentsPostRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<{ [key: string]: NodeInCultureWithContentBE; }>>;
    public cultureCodeProductsContentsPost(requestParameters: CultureCodeProductsContentsPostRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeProductsContentsPost.');
        }
        const contentType = requestParameters.contentType;
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cultureCodeProductsContentsPost.');
        }
        const productNumbers = requestParameters.productNumbers;
        if (productNumbers === null || productNumbers === undefined) {
            throw new Error('Required parameter productNumbers was null or undefined when calling cultureCodeProductsContentsPost.');
        }
        const status = requestParameters.status;
        const hidePath = requestParameters.hidePath;
        const filter = requestParameters.filter;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (contentType) {
            contentType.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'contentType[]');
            })
        }
        if (hidePath !== undefined && hidePath !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>hidePath, 'hidePath');
        }
        if (filter) {
            filter.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-www-form-urlencoded'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (productNumbers) {
            if (localVarUseForm) {
                productNumbers.forEach((element) => {
                    localVarFormParams = localVarFormParams.append('productNumbers[]', <any>element) as any || localVarFormParams;
            })
            } else {
                localVarFormParams = localVarFormParams.append('productNumbers[]', productNumbers.join(COLLECTION_FORMATS['csv'])) as any || localVarFormParams;
            }
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.post<{ [key: string]: NodeInCultureWithContentBE; }>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/products/contents`,
            localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get contents for a single product
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cultureCodeProductsProductNumberContentsGet(requestParameters: CultureCodeProductsProductNumberContentsGetRequestParams, observe?: 'body', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<NodeInCultureWithContentBE>;
    public cultureCodeProductsProductNumberContentsGet(requestParameters: CultureCodeProductsProductNumberContentsGetRequestParams, observe?: 'response', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<NodeInCultureWithContentBE>>;
    public cultureCodeProductsProductNumberContentsGet(requestParameters: CultureCodeProductsProductNumberContentsGetRequestParams, observe?: 'events', reportProgress?: boolean, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<NodeInCultureWithContentBE>>;
    public cultureCodeProductsProductNumberContentsGet(requestParameters: CultureCodeProductsProductNumberContentsGetRequestParams, observe: any = 'body', reportProgress: boolean = false, requestOptions?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        const cultureCode = requestParameters.cultureCode;
        if (cultureCode === null || cultureCode === undefined) {
            throw new Error('Required parameter cultureCode was null or undefined when calling cultureCodeProductsProductNumberContentsGet.');
        }
        const productNumber = requestParameters.productNumber;
        if (productNumber === null || productNumber === undefined) {
            throw new Error('Required parameter productNumber was null or undefined when calling cultureCodeProductsProductNumberContentsGet.');
        }
        const contentType = requestParameters.contentType;
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cultureCodeProductsProductNumberContentsGet.');
        }
        const status = requestParameters.status;
        const options = requestParameters.options;

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (contentType) {
            contentType.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'contentType[]');
            })
        }
        if (status) {
            status.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'status[]');
            })
        }
        if (options) {
            options.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'options[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (Bearer) required
        localVarCredential = this.configuration.lookupCredential('Bearer');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = requestOptions && requestOptions.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = requestOptions && requestOptions.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        return this.httpClient.get<NodeInCultureWithContentBE>(`${this.configuration.basePath}/${encodeURIComponent(String(cultureCode))}/products/${encodeURIComponent(String(productNumber))}/contents`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
